generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String               @id @default(cuid())
  email            String               @unique
  password         String
  name             String
  phone            String?
  specialization   String?
  avatar           String?
  role             Role                 @default(CLIENT)
  businessId       String?              @db.VarChar(255)
  workingHours     Json?
  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt
  registrationIp   String?
  bookings         Booking[]
  employeeBookings Booking[]            @relation("EmployeeBookings")
  ownedBusinesses  Business[]           @relation("BusinessOwner")
  clientLinks      ClientBusinessLink[] @relation("ClientLinks")
  consentDocuments ConsentDocument[]
  consentForms     ConsentForm[]
  employeeHolidays EmployeeHoliday[]
  resetTokens      PasswordResetToken[]
  sessions         UserSession[]
  business         Business?            @relation(fields: [businessId], references: [id])
}

model RegistrationAttempt {
  id            String   @id @default(cuid())
  email         String
  ipAddress     String
  userAgent     String?
  success       Boolean  @default(false)
  failureReason String?
  captchaScore  Float?
  createdAt     DateTime @default(now())

  @@index([email])
  @@index([ipAddress])
  @@index([createdAt])
}

model LoginAttempt {
  id            String   @id @default(cuid())
  email         String?
  ipAddress     String
  userAgent     String?
  success       Boolean  @default(false)
  failureReason String?
  createdAt     DateTime @default(now())

  @@index([email])
  @@index([ipAddress])
  @@index([createdAt])
}

model IpBlacklist {
  id        String    @id @default(cuid())
  ipAddress String    @unique
  reason    String?
  blockedAt DateTime  @default(now())
  expiresAt DateTime?
  createdAt DateTime  @default(now())

  @@index([ipAddress])
  @@index([expiresAt])
}

model Business {
  id               String                  @id @default(cuid())
  name             String
  email            String?                 @unique
  domain           String                  @unique
  businessType     BusinessType            @default(GENERAL)
  ownerId          String
  workingHours     Json?
  qrCodeUrl        String?
  address          String?
  phone            String?
  latitude         Float?
  longitude        Float?
  createdAt        DateTime                @default(now())
  updatedAt        DateTime                @updatedAt
  currentPlanId    String?
  status           BusinessStatus          @default(ACTIVE)
  trialEndDate     DateTime?
  trialStartDate   DateTime?
  aiUsageLogs      AiUsageLog[]
  bookings         Booking[]
  currentPlan      SubscriptionPlan?       @relation("BusinessCurrentPlan", fields: [currentPlanId], references: [id])
  owner            User                    @relation("BusinessOwner", fields: [ownerId], references: [id])
  bankAccount      BusinessBankAccount?
  kycStatus        BusinessKycStatus?
  legalInfo        BusinessLegalInfo?
  representative   BusinessRepresentative?
  clientLinks      ClientBusinessLink[]    @relation("BusinessLinks")
  consentDocuments ConsentDocument[]
  consentForms     ConsentForm[]
  holidays         Holiday[]
  invoices         Invoice[]
  payments         Payment[]
  services         Service[]
  smsUsageLogs     SmsUsageLog[]
  subscriptions    Subscription[]
  employees        User[]
}

model ClientBusinessLink {
  id         String   @id @default(cuid())
  clientId   String
  businessId String
  createdAt  DateTime @default(now())
  method     String?
  business   Business @relation("BusinessLinks", fields: [businessId], references: [id])
  client     User     @relation("ClientLinks", fields: [clientId], references: [id])

  @@unique([clientId, businessId])
  @@index([businessId])
}

model Holiday {
  id         String   @id @default(cuid())
  businessId String
  startDate  DateTime
  endDate    DateTime
  reason     String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  business   Business @relation(fields: [businessId], references: [id], onDelete: Cascade)

  @@index([businessId])
  @@index([startDate, endDate])
}

model Service {
  id         String    @id @default(cuid())
  name       String
  duration   Int
  price      Float
  notes      String?
  businessId String
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  bookings   Booking[]
  business   Business  @relation(fields: [businessId], references: [id])
}

model Booking {
  id               String               @id @default(cuid())
  clientId         String
  businessId       String
  serviceId        String
  employeeId       String?
  date             DateTime
  paid             Boolean              @default(false)
  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt
  status           BookingStatus        @default(CONFIRMED)
  reminderSentAt   DateTime?
  paymentMethod    PaymentMethod?
  paymentReused    Boolean              @default(false)
  paymentStatus    BookingPaymentStatus @default(PENDING)
  business         Business             @relation(fields: [businessId], references: [id])
  client           User                 @relation(fields: [clientId], references: [id])
  employee         User?                @relation("EmployeeBookings", fields: [employeeId], references: [id])
  service          Service              @relation(fields: [serviceId], references: [id])
  consentDocuments ConsentDocument[]
  consentForm      ConsentForm?         @relation("BookingConsent")
  payments         Payment[]
}

model ConsentForm {
  id           String        @id @default(cuid())
  bookingId    String        @unique
  clientId     String
  businessId   String
  pdfUrl       String
  signature    String?
  templateType BusinessType?
  formData     Json?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  booking      Booking       @relation("BookingConsent", fields: [bookingId], references: [id], onDelete: Cascade)
  business     Business      @relation(fields: [businessId], references: [id])
  client       User          @relation(fields: [clientId], references: [id])
}

model ConsentDocument {
  id         String                @id @default(cuid())
  bookingId  String
  clientId   String
  businessId String
  pdfUrl     String
  fileName   String?
  source     ConsentDocumentSource
  createdAt  DateTime              @default(now())
  booking    Booking               @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  business   Business              @relation(fields: [businessId], references: [id])
  client     User                  @relation(fields: [clientId], references: [id])

  @@index([clientId, businessId])
  @@index([bookingId])
}

model DemoBooking {
  id        String   @id @default(cuid())
  firstName String
  lastName  String
  email     String
  phone     String
  dateTime  DateTime
  meetLink  String
  createdAt DateTime @default(now())
}

model EmployeeHoliday {
  id         String   @id @default(cuid())
  employeeId String
  startDate  DateTime
  endDate    DateTime
  reason     String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  employee   User     @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@index([employeeId])
  @@index([startDate, endDate])
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}

model UserSession {
  id           String    @id @default(cuid())
  userId       String
  tokenHash    String    @unique // Hash of JWT pentru invalidare
  userAgent    String?
  ipAddress    String?
  lastActivity DateTime  @default(now())
  expiresAt    DateTime
  createdAt    DateTime  @default(now())
  isActive     Boolean   @default(true)
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([tokenHash])
  @@index([expiresAt])
}

model SubscriptionPlan {
  id                String         @id @default(cuid())
  name              String         @unique
  price             Float
  currency          String         @default("RON")
  billingCycle      String         @default("MONTHLY")
  smsIncluded       Int?
  aiIncluded        Int?
  description       String?
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  maxEmployees      Int?
  currentBusinesses Business[]     @relation("BusinessCurrentPlan")
  subscriptions     Subscription[]
}

model Subscription {
  id                   String             @id @default(cuid())
  businessId           String
  planId               String
  status               SubscriptionStatus @default(TRIAL)
  currentPeriodStart   DateTime
  currentPeriodEnd     DateTime
  billingMethod        PaymentMethod
  amount               Float
  currency             String             @default("RON")
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  stripeCustomerId     String?
  stripeSubscriptionId String?            @unique
  autoBillingConsent   Boolean            @default(false)
  autoBillingConsentAt DateTime?
  autoBillingConsentIP String?
  autoBillingEnabled   Boolean            @default(false)
  nextBillingDate      DateTime?
  invoices             Invoice[]
  business             Business           @relation(fields: [businessId], references: [id])
  plan                 SubscriptionPlan   @relation(fields: [planId], references: [id])
}

model Invoice {
  id             String        @id @default(cuid())
  subscriptionId String
  businessId     String
  amount         Float
  currency       String        @default("RON")
  issuedAt       DateTime      @default(now())
  paidAt         DateTime?
  paymentMethod  PaymentMethod
  status         InvoiceStatus @default(PAID)
  applicationFee Float?
  metadata       Json?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  business       Business      @relation(fields: [businessId], references: [id])
  subscription   Subscription  @relation(fields: [subscriptionId], references: [id])
  payments       Payment[]
}

model Payment {
  id                   String        @id @default(cuid())
  businessId           String
  bookingId            String?
  invoiceId            String?
  amount               Float
  currency             String        @default("RON")
  method               PaymentMethod
  status               PaymentStatus @default(PENDING)
  applicationFee       Float?
  isCashSelfReported   Boolean       @default(false)
  metadata             Json?
  createdAt            DateTime      @default(now())
  updatedAt            DateTime      @updatedAt
  amountPerInstallment Float?
  externalPaymentId    String?       @unique
  gateway              String        @default("stripe")
  installments         Int?
  booking              Booking?      @relation(fields: [bookingId], references: [id])
  business             Business      @relation(fields: [businessId], references: [id])
  invoice              Invoice?      @relation(fields: [invoiceId], references: [id])
}

model SmsUsageLog {
  id         String       @id @default(cuid())
  businessId String?
  type       SmsUsageType @default(NOTIFICATION)
  messageId  String?
  phoneHash  String?
  cost       Float?
  createdAt  DateTime     @default(now())
  metadata   Json?
  business   Business?    @relation(fields: [businessId], references: [id])

  @@index([businessId])
  @@index([createdAt])
}

model AiUsageLog {
  id           String    @id @default(cuid())
  businessId   String?
  userId       String?
  userRole     Role?
  toolName     String?
  tokensUsed   Int?
  costEstimate Float?
  statusCode   Int?
  createdAt    DateTime  @default(now())
  metadata     Json?
  business     Business? @relation(fields: [businessId], references: [id])

  @@index([businessId])
  @@index([createdAt])
}

model BusinessLegalInfo {
  id                   String   @id @default(cuid())
  businessId           String   @unique
  legalEntityName      String
  cui                  String   @unique
  tradeRegisterNumber  String?
  vatStatus            String?
  vatCode              String?
  registeredStreet     String
  registeredNumber     String
  registeredCity       String
  registeredCounty     String
  registeredPostalCode String
  businessType         String
  websiteUrl           String?
  businessDescription  String?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  business             Business @relation(fields: [businessId], references: [id], onDelete: Cascade)
}

model BusinessRepresentative {
  id               String   @id @default(cuid())
  businessId       String   @unique
  fullName         String
  cnp              String?
  nationalIdType   String?
  nationalIdSeries String?
  nationalIdNumber String?
  dateOfBirth      DateTime
  residenceAddress String
  email            String
  phone            String
  roleInCompany    String
  beneficialOwner  Boolean  @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  business         Business @relation(fields: [businessId], references: [id], onDelete: Cascade)
}

model BusinessBankAccount {
  id            String   @id @default(cuid())
  businessId    String   @unique
  iban          String   @unique
  bankName      String
  accountHolder String
  validated     Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  business      Business @relation(fields: [businessId], references: [id], onDelete: Cascade)
}

model BusinessKycStatus {
  id                       String    @id @default(cuid())
  businessId               String    @unique
  status                   String    @default("PENDING")
  stripeConnectAccountId   String?   @unique
  stripeVerificationStatus String?
  rejectionReason          String?
  submittedAt              DateTime?
  verifiedAt               DateTime?
  createdAt                DateTime  @default(now())
  updatedAt                DateTime  @updatedAt
  business                 Business  @relation(fields: [businessId], references: [id], onDelete: Cascade)
}

model PlatformSettings {
  id          String   @id @default(cuid())
  key         String   @unique
  value       String
  description String?
  updatedAt   DateTime @updatedAt
  updatedBy   String?
}

model SystemAuditLog {
  id        String   @id @default(cuid())
  actorId   String?
  actorRole Role?
  action    String
  entity    String?
  entityId  String?
  before    Json?
  after     Json?
  createdAt DateTime @default(now())

  @@index([entity, entityId])
  @@index([createdAt])
}

enum BookingStatus {
  PENDING_CONSENT
  CONFIRMED
  CANCELLED
}

enum BookingPaymentStatus {
  PENDING
  PAID
  FAILED
}

enum Role {
  SUPERADMIN
  BUSINESS
  EMPLOYEE
  CLIENT
}

enum BusinessType {
  GENERAL
  BEAUTY_WELLNESS
  MEDICAL_DENTAL
  THERAPY_COACHING
  SPORT_OUTDOOR
  HOME_FREELANCE
}

enum BusinessStatus {
  ACTIVE
  SUSPENDED
}

enum ConsentDocumentSource {
  DIGITAL_SIGNATURE
  BUSINESS_UPLOAD
}

enum PaymentMethod {
  CARD
  APPLE_PAY
  GOOGLE_PAY
  KLARNA
  CASH
  OFFLINE
}

enum PaymentStatus {
  SUCCEEDED
  FAILED
  REFUNDED
  PENDING
  CANCELED
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  TRIAL
}

enum InvoiceStatus {
  PAID
  DUE
  FAILED
  PENDING
}

enum SmsUsageType {
  NOTIFICATION
  CONFIRMATION
  REMINDER
  CANCELLATION
  DEMO
  MARKETING
  OTHER
}

model WebhookEvent {
  id        String   @id @default(cuid())
  eventId   String   @unique
  type      String
  processed Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([eventId])
  @@index([type])
  @@index([processed])
}
